- [练习 16.1](#练习-161)
- [练习16.2](#练习162)
- [练习 16.3](#练习-163)
- [练习 16.4](#练习-164)
- [练习 16.5](#练习-165)
- [练习 16.6](#练习-166)
- [练习 16.7](#练习-167)
- [练习 16.8](#练习-168)

# 练习 16.1
> 给出实例化的定义。

解：当调用一个函数模板时，编译器会利用给定的函数实参来推断模板实参，用此实际实参代替模板参数来创建出模板的一个新的“实例”，也就是一个真正可以调用的函数，这个过程称为实例化。

# 练习16.2
> 编写并测试你自己版本的 compare 函数。

```cpp
#include <iostream>
using namespace std;

template <typename T>
int compare(const T& a,const T& b)
{
    return a<b?-1:a>b?1:0;
}

int main()
{
    cout<<compare(1,2)<<endl;
    cout<<compare(2,1)<<endl;
    cout<<compare(6.6,7.7)<<endl;
    cout<<compare(7.7,6.6)<<endl;
    return 0;
}
```

# 练习 16.3
> 对两个 `Sales_data` 对象调用你的 `compare` 函数，观察编译器在实例化过程中如何处理错误。

解：`error: no match for 'operator<' `

# 练习 16.4
> 编写行为类似标准库 `find` 算法的模版。函数需要两个模版类型参数，一个表示函数的迭代器参数，另一个表示值的类型。使用你的函数在一个 `vector<int>` 和一个`list<string>`中查找给定值。

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <list>
using namespace std;

template <typename Iterator, typename Value>
Iterator find(Iterator first, Iterator last, const Value& v)
{
    while(first != last && *first != v)first++;
    return first;
}

int main()
{
    vector<int> vi{0,2,4,6,8,10};
    list<string> ls{"hello","world","!"};
    auto iter = find(vi.begin(),vi.end(),6);
    if(iter == vi.end())cout<<"can not find 6"<<endl;
    else cout<<"find 6 at position"<<iter-vi.begin()<<endl;

    auto iter1 = find(ls.begin(),ls.end(),"mom");
    if(iter1 == ls.end())cout<<"can not find mom"<<endl;
    else cout<<"found mom"<<endl;

    return 0;
}
```

# 练习 16.5
> 为6.2.4节中的`print`函数编写模版版本，它接受一个数组的引用，能处理任意大小、任意元素类型的数组。

```cpp
#include <iostream>
#include <string>
using namespace std;

// C语言版本：T 表示类型参数，N 表示数组大小
template <typename T, size_t N>
void print(const T (&a)[N])
{
    for(auto iter = begin(a); iter != end(a); iter++){
        cout<<*iter<<" ";
    }
    cout<<endl;
}

// C++版本
template<typename Array>
void print(const Array& a)
{
    for(const auto& i:a)cout<<i<<" ";
    cout<<endl;
}

int main()
{
    int a[6]{0,2,4,6,8,10};
    string vs[3]{"hello","world","!"};

    print(a);
    print(vs);

    return 0;
}
```

# 练习 16.6
> 你认为接受一个数组实参的标准库函数 `begin` 和 `end` 是如何工作的？定义你自己版本的 `begin` 和 `end`。

解：begin 应返回数组首元素指针，因此是 return &a[0]。end 返回尾后指针，因此在 begin 上加上数组大小 N 即可。
```cpp
#include <iostream>
#include <string>
using namespace std;

// 前向声明
template <typename T, size_t N>
const T* my_begin(const T(&a)[N]);

template <typename T, size_t N>
const T* my_end(const T (&a)[N]);

// C语言版本：T 表示类型参数，N 表示数组大小
template <typename T, size_t N>
void print(const T (&a)[N])
{
    for(auto iter = my_begin(a); iter != my_end(a); iter++){
        cout<<*iter<<" ";
    }
    cout<<endl;
}

template <typename T, size_t N>
const T* my_begin(const T(&a)[N])
{
    return &a[0];
}

template <typename T, size_t N>
const T* my_end(const T (&a)[N])
{
    return &a[0]+N;
}

int main()
{
    int a[6]{0,2,4,6,8,10};
    string vs[3]{"hello","world","!"};

    print(a);
    print(vs);

    return 0;
}
```

# 练习 16.7
> 编写一个 constexpr 模版，返回给定数组的大小。

解：由于数组大小是数组类型的一部分，可以通过模板参数直接获取，因此在 constexpr 模板中直接返回它即可。
```cpp
#include <iostream>
#include <string>
using namespace std;

template <typename T, size_t N>
constexpr int arr_size(const T (&a)[N])
{
    return N;
}

template <typename T, size_t N>
void print(const T (&a)[N])
{
    for(int i=0;i<arr_size(a);++i){
        cout<<a[i]<<" ";
    }
    cout<<endl;
}

int main()
{
    int a[6]{0,2,4,6,8,10};
    string vs[3]{"hello","world","!"};

    print(a);
    print(vs);

    return 0;
}
```

# 练习 16.8
> 在第97页的“关键概念”中，我们注意到，C++程序员喜欢使用 `!=` 而不喜欢 `<` 。解释这个习惯的原因。

解：泛型编程的一个目的是令算法是通用的--适用于不同类型。所有标准库容器都定义了 `==` 和 `!=` 运算符，但其中只有少数定义了 `<` 运算符。尽管，尽量使用 `!=` 而不是 `<`，可减少算法适用容器的限制。