# gdb 查看代码堆栈的信息

> [Linux中用gdb 查看代码堆栈的信息](https://www.cnblogs.com/chengliangsheng/p/3597010.html)

core dump 一般是在 segmentation fault（段错误）的情况下产生的文件，需要通过设置 ulimit 来设置才会得到的。

```bash
# 调试命令如下。其中 filename 表示产生 core 文件的可执行文件， core 就是产生的 dump 文件
gdb filename core

# n是一个从0开始的整数，是栈中的层编号。比如：frame 0，表示栈顶，frame 1，表示栈的第二层。
frame
f

# 表示向栈的上面移动n层，可以不打n，表示向上移动一层。
up

# 表示向栈的下面移动n层，可以不打n，表示向下移动一层。
down

# 上面的命令，都会打印出移动到的栈层的信息。如果你不想让其打出信息。你可以使用这三个命令：
select-frame 对应于 frame 命令。
up-silently 对应于 up 命令。
down-silently 对应于 down 命令。

# 会打印出这些信息：栈的层编号，当前的函数名，函数参数值，函数所在文件及行号，函数执行到的语句。
frame 或 f

# 这个命令会打印出更为详细的当前栈层的信息，只不过，大多数都是运行时的内存地址。比如：函数地址，调用函数的地址，被调用函数的地址，目前的函数是由什么样的程序语言写成的、函数参数地址及值、局部变量的地址等等。
info frame
info f

# 打印出当前函数的参数名及其值。
info args

# 打印出当前函数中所有局部变量及其值。
info locals

# 打印出当前的函数中的异常处理信息。
info catch
```

GDB 可以打印出所调试程序的源代码，当然，**在程序编译时一定要加上 `-g` 的参数，把源程序信息编译到执行文件中**。不然就看不到源程序了。当程序停下来以后，GDB会报告程序停在了哪个文件的第几行上。可以用list命令来打印程序的源代码。下面是查看源代码的 GDB 命令：

```bash
# 显示程序第linenum行的周围的源程序。
list

# 显示函数名为function的函数的源程序。
list

# 显示当前行后面的源程序。
list

# 显示当前行前面的源程序。
list -

# 一般是打印当前行的上5行和下5行，如果显示函数是是上2行下8行，默认是10行，当然，你也可以定制显示的范围，使用下面命令可以设置一次显示源程序的行数。
# 设置一次显示源代码的行数。
set listsize

# 查看当前listsize的设置。
show listsize

# list命令还有下面的用法：
# 显示从first行到last行之间的源代码。
list ,

# 显示从当前行到last行之间的源代码。
list ,
# 往后显示源代码。
list +

# 一般来说在list后面可以跟以下这们的参数：行号。
# <+offset> 当前行号的正偏移量。
# <-offset> 当前行号的负偏移量。
# 哪个文件的哪一行。
# 函数名。
# 哪个文件中的哪个函数。
# <*address> 程序运行时的语句在内存中的地址。
```



