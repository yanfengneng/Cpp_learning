# C++ 中一个空类的字节大小是多少？

在 C++ 中，**一个空类的大小通常为 1 字节**，尽管它本身没有任何成员变量。这是因为 C++ 需要为每个对象分配一个独立的地址，以便能够区分不同的对象，即使这些对象是空的。

```cpp
#include <iostream>
using namespace std;

class Empty{};
int main()
{
  Empty obj;
  // 输出 1
  cout << sizeof(obj) << endl;
  return 0;
}
```

原因分析：

**1）对象地址唯一性**

* 每个对象在内存中必须有一个唯一的地址，即使是空对象，也需要占用一定的空间来保证地址不同。
* 如果空类的大小为 0，那么不同的对象可能会拥有相同的地址，从而导致对象管理的混乱。

**2）符合标准**

* C++ 标准规定，任何对象的大小都不能为 0。因此，编译器会为空类分配至少 1 字节的空间。

**3）编译器行为**

* 空类的大小由编译器决定，大多数现代编译器会为空类分配 1 字节的空间。
* 一些编译器可能会因为对齐要求而分配更多的空间，例如当空类作为其他类的基类时。

当一个空类被用作其他类的基类时，由于 C++ 支持**空基类优化（Empty Base Optimization, EBO）**，可能不会为空基类分配额外的空间。

```cpp
#include <iostream>
using namespace std;

class Empty {};

class Derived : public Empty {
  int x;
};
int main() {
  // 输出 1
  std::cout << "Size of Empty: " << sizeof(Empty) << " bytes" << std::endl;
  // 输出 4
  std::cout << "Size of Derived: " << sizeof(Derived) << " bytes" << std::endl;
}
```



# 编译时遇到 undefined symbol，你是如何解决的？

遇到 `undefined symbol` 错误通常是在链接阶段发生的，这意味着编译器在编译过程中找到了符号的声明，但链接器在链接过程中找不到这些符号的定义。

**解决问题的步骤：**

1. **检查源代码和头文件，确保所有函数和变量都已经正确定义**。如果一个函数在头文件中被声明（例如`extern void func();`），你需要在某个源文件中找到或提供这个函数的定义（例如`void func() { // 实现 }`）。
2. **验证库和对象文件**。如果未定义的符号是某个库中的函数或变量，确保：1）已经包含了定义这个符号的库文件；2）使用正确的库版本，有时不同版本的库中可能缺少特定的符号；3）在链接命令中正确指定了库文件。例如，使用`g++`链接时，确保在命令行中包含了所有必要的库，如`-lmath`。
3. **检查链接顺序**。**链接器通常从左到右解析库**，<font color=blue>如果库 A 依赖于库 B 中的符号，库 A 需要在库B之前列出（被依赖的库需要在后面给出）。</font>例如，如果你的程序依赖库`libA`和`libB`，并且`libA`使用了`libB`的符号，则链接命令应该是：`g++ your_program.o -lA -lB`。
4. **检查编译选项：确保编译器的编译选项正确无误**。例如，对于C++程序，确保使用了`g++`而不是`gcc`。此外，检查是否为编译器提供了正确的路径来查找头文件和库文件，如使用`-I`（头文件搜索路径）和`-L`（库文件搜索路径）选项。
5. **检查动态链接库的依赖**。如果程序使用了动态链接库（如`.so`文件），使用 `ldd` 命令来检查你的程序或库是否找到了所有必要的动态链接库：`ldd your_program`。
6. **静态和动态库混用问题**。如果同时使用了静态和动态版本的同一库，可能会导致链接混乱。确保链接到的是正确类型的库，通常优先使用动态库，除非有特定理由使用静态库。
7. **重新编译**。有时，重新编译所有相关的源文件和库可以解决符号不匹配的问题，特别是当移植代码或改变编译器设置时。