- [前言](#前言)
- [一、static\_cast 静态转换](#一static_cast-静态转换)
- [二、dynamic\_cast 动态转换](#二dynamic_cast-动态转换)
- [三、const\_cast 常量转换](#三const_cast-常量转换)
- [四、reinterpret\_cast 不相关类型的转换](#四reinterpret_cast-不相关类型的转换)
    - [5. C 风格类型转换](#5-c-风格类型转换)
    - [总结](#总结)

参考：[static_cast和dynamic_cast详解](https://blog.csdn.net/u014624623/article/details/79837849)

> [C++四种强制转换](https://blog.csdn.net/daaikuaichuan/article/details/79476501)

[C++中的四种强制类型转换符详解](https://www.cnblogs.com/linuxAndMcu/p/10387829.html)

# 前言

C++ 既支持 C 风格的类型转换，又有自己风格的类型转换。C 风格的转换格式很简单，但是有不少缺点：

* 1）**转换太过随意，可以在任意类型之间转换**。可以把一个指向 const 对象的指针转换为指向非 const 对象的指针，可以把一个指向基类对象的指针转换为一个指向派生类对象的指针，这些转换之间的差距是非常巨大的，但是传统的 C 语言风格的类型转换没有区分这些。
* 2）**C 风格的转换没有统一的关键字和标识符**。对于大型系统，做代码排查时很容易遗漏和忽略。

C++ 风格完美的解决了上面两个问题：

* 1）**对类型转换做了细分，提供了四种不同类型的转换**，以支持不同需求的转换。
* 2）**类型转换有了统一的标识符，利于代码排查和检视**。

C++ 主要提供了四种类型转换操作符：`static_cast`、`dynamic_cast`、`const_cast` 和 `reinterpret_cast`，它们都是类模板。**格式均为 `xxx_cast<T> (expression)`，其中 `T` 表示要转换成什么类型，`expression` 表示被转换类型的目标变量**。

这些转换方式比 C 风格的强制类型转换（如 `(int)x`）更加安全和明确。

# 一、static_cast 静态转换

`static_cast` 用于执行显式类型转换，**但它在编译时执行检查**。有以下的使用场景：

* 1）**基本数据类型之间的转换**，<font color=alice>如把 int 转换为 char，这种转换带来的安全性问题由程序员来保证。</font>
* 2）在**有类型指针与 `void *` 之间转换**，如将 `void *` 转换为具体类型的指针。
* 3）用于类层次结构中**基类和派生类之间指针或引用的转换**。
  * **上行转换（派生类 => 基类）是安全的**。
  * **下行转换（基类 => 派生类）：由于没有动态类型检查，所以是不安全的**。

<img src="Image/赋值兼容原则.png" alt="image-20231207153856083" style="zoom:67%;" />

**使用特点：**

* 主要执行非多态的转换操作，用于代替 C 语言风格中通常的转换操作。
* 隐式转换都建议使用 `static_cast` 进行标明和替换。
* 不能使用 `static_cast` 在有类型指针内转换。

```cpp
int main() {
    int a = 10;
    double b = static_cast<double>(a); // int 转 double
    std::cout << b << std::endl;

    void* p = &a;
    int* ip = static_cast<int*>(p); // void* 转 int*
    std::cout << *ip << std::endl;

    return 0;
}
```

# 二、dynamic_cast 动态转换

`dynamic_cast` 主要用于多态类型（带有虚函数的类层次结构）之间的指针或引用转换。它可以在运行时检查转换是否安全，适合于从基类指针或引用向下转换为派生类指针或引用。如果转换失败，会返回 `nullptr`（对于指针）或抛出 `bad_cast` 异常（对于引用）。

```cpp
class Base {
    virtual void func() {} // 必须有虚函数
};

class Derived : public Base {
};

int main() {
    Base* base = new Derived();
    Derived* derived = dynamic_cast<Derived*>(base); // 安全转换，成功
    if (derived) {
        std::cout << "Cast successful" << std::endl;
    }

    Base* base2 = new Base();
    Derived* derived2 = dynamic_cast<Derived*>(base2); // 转换失败
    if (!derived2) {
        std::cout << "Cast failed" << std::endl;
    }

    delete base;
    delete base2;

    return 0;
}
```

# 三、const_cast 常量转换

`const_cast` 主要用于在同类型的 `const` 和 `non-const` 对象之间进行转换。它只能移除或添加 `const` 和 `volatile` 修饰符，通常用于需要在某些函数内修改常量值的场景。

```cpp
void func(const int* p) {
    int* modifiable = const_cast<int*>(p); // 移除 const 属性
    *modifiable = 20; // 修改值
}

int main() {
    const int a = 10;
    func(&a); // 虽然不推荐，但这是 const_cast 的用途之一
    std::cout << a << std::endl; // a 的值在未定义行为的情况下可能会改变

    return 0;
}
```

# 四、reinterpret_cast 不相关类型的转换

`reinterpret_cast` 是一种非常危险的类型转换，允许在几乎所有类型之间进行转换，包括不相关类型的指针、整数与指针之间的转换。它不会进行任何检查或处理，只是单纯地重解释位模式。它通常用于底层的硬件接口编程或需要强制转换类型的特殊场景。

```cpp
int main() {
    int a = 65;
    char* p = reinterpret_cast<char*>(&a); // int* 转 char*
    std::cout << *p << std::endl; // 打印字符 'A'

    int b = reinterpret_cast<int>(p); // char* 转 int
    std::cout << b << std::endl; // 打印指针值（通常为内存地址）

    return 0;
}
```

### 5. C 风格类型转换
C 风格的类型转换直接使用括号语法进行，如 `(Type)expression`。这种转换不区分 `static_cast`、`dynamic_cast`、`const_cast` 和 `reinterpret_cast`，因此更不安全，容易引发未定义行为。C++ 强烈建议使用上面的 C++ 风格转换。

```cpp
int main() {
    int a = 10;
    double b = (double)a; // C 风格的强制转换
    std::cout << b << std::endl;

    return 0;
}
```

### 总结
- `static_cast` 用于大部分类型安全的转换，适用于普通的基础类型转换和继承结构中向上和向下转换。
- `dynamic_cast` 用于在多态类型中进行安全的向下转换。
- `const_cast` 用于在 `const` 和 `non-const` 类型之间进行转换。
- `reinterpret_cast` 用于进行不安全的低级别转换。
- C 风格转换虽然方便但不建议使用，因为它不具备类型安全性。

了解这些转换的适用场景和限制，对于编写安全可靠的 C++ 程序非常重要。